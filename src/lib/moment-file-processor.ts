'use client'

import matter from 'gray-matter'
import { PivotalMoment, MomentCorrelation } from '@/types/moments'
import { loadConfigClient } from '@/lib/config-loader.client'

// File-based moment persistence system
export class MomentFileProcessor {
  private static instance: MomentFileProcessor | null = null
  
  static getInstance(): MomentFileProcessor {
    if (!MomentFileProcessor.instance) {
      MomentFileProcessor.instance = new MomentFileProcessor()
    }
    return MomentFileProcessor.instance
  }

  /**
   * Generate a safe filename from moment title
   */
  private generateFilename(moment: PivotalMoment): string {
    const title = moment.title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .substring(0, 50) // Limit length
      .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    
    const date = new Date(moment.extractedAt).toISOString().split('T')[0]
    const source = moment.source.type.charAt(0) // 'c' for company, 't' for technology
    
    return `${date}-${source}-${title}-${moment.id.substring(0, 8)}.md`
  }

  /**
   * Convert moment to markdown with frontmatter
   */
  private momentToMarkdown(moment: PivotalMoment): string {
    const frontmatter = {
      id: moment.id,
      title: moment.title,
      description: moment.description,
      extractedAt: moment.extractedAt.toISOString(),
      source: {
        type: moment.source.type,
        id: moment.source.id,
        name: moment.source.name,
        contentId: moment.source.contentId,
        filePath: moment.source.filePath
      },
      classification: {
        microFactors: moment.classification.microFactors,
        macroFactors: moment.classification.macroFactors,
        confidence: moment.classification.confidence,
        reasoning: moment.classification.reasoning,
        keywords: moment.classification.keywords
      },
      impact: {
        score: moment.impact.score,
        reasoning: moment.impact.reasoning
      },
      entities: moment.entities,
      timeline: {
        estimatedDate: moment.timeline.estimatedDate?.toISOString(),
        timeframe: moment.timeline.timeframe,
        isHistorical: moment.timeline.isHistorical
      },
      version: "1.0",
      generatedBy: "Moments AI Analysis Engine",
      lastModified: new Date().toISOString()
    }

    // Create markdown content
    const content = `# ${moment.title}

${moment.description}

## Analysis Summary

This pivotal moment was identified and classified by AI analysis with **${moment.classification.confidence} confidence** and an **impact score of ${moment.impact.score}/100**.

### Key Factors

**Micro Factors:** ${moment.classification.microFactors.join(', ') || 'None'}
**Macro Factors:** ${moment.classification.macroFactors.join(', ') || 'None'}

### Entities Involved

${moment.entities.companies.length > 0 ? `**Companies:** ${moment.entities.companies.join(', ')}` : ''}
${moment.entities.technologies.length > 0 ? `**Technologies:** ${moment.entities.technologies.join(', ')}` : ''}
${moment.entities.people.length > 0 ? `**People:** ${moment.entities.people.join(', ')}` : ''}
${moment.entities.locations.length > 0 ? `**Locations:** ${moment.entities.locations.join(', ')}` : ''}

### Source Information

- **Source Type:** ${moment.source.type}
- **Source Name:** ${moment.source.name}
- **File Path:** \`${moment.source.filePath}\`

### Timeline Context

${moment.timeline.estimatedDate ? `**Estimated Date:** ${new Date(moment.timeline.estimatedDate).toLocaleDateString()}` : ''}
${moment.timeline.timeframe ? `**Timeframe:** ${moment.timeline.timeframe}` : ''}
**Historical:** ${moment.timeline.isHistorical ? 'Yes' : 'No'}

## Original Content

\`\`\`
${moment.content}
\`\`\`

---

*This moment was automatically generated by the Moments AI Analysis Engine on ${new Date(moment.extractedAt).toLocaleString()}.*
`

    return matter.stringify(content, frontmatter)
  }

  /**
   * Parse markdown file back to moment object
   */
  private markdownToMoment(fileContent: string, filename: string): PivotalMoment | null {
    try {
      const parsed = matter(fileContent)
      const data = parsed.data
      
      // Validate required fields
      if (!data.id || !data.title || !data.extractedAt) {
        console.warn(`Invalid moment file: ${filename} - missing required fields`)
        return null
      }

      const moment: PivotalMoment = {
        id: data.id,
        title: data.title,
        description: data.description || '',
        content: parsed.content || '',
        source: {
          type: data.source?.type || 'company',
          id: data.source?.id || '',
          name: data.source?.name || '',
          contentId: data.source?.contentId || '',
          filePath: data.source?.filePath || ''
        },
        classification: {
          microFactors: data.classification?.microFactors || [],
          macroFactors: data.classification?.macroFactors || [],
          confidence: data.classification?.confidence || 'medium',
          reasoning: data.classification?.reasoning || '',
          keywords: data.classification?.keywords || []
        },
        extractedAt: new Date(data.extractedAt),
        impact: {
          score: data.impact?.score || 50,
          reasoning: data.impact?.reasoning || ''
        },
        entities: {
          companies: data.entities?.companies || [],
          technologies: data.entities?.technologies || [],
          people: data.entities?.people || [],
          locations: data.entities?.locations || []
        },
        timeline: {
          estimatedDate: data.timeline?.estimatedDate ? new Date(data.timeline.estimatedDate) : undefined,
          timeframe: data.timeline?.timeframe,
          isHistorical: data.timeline?.isHistorical || false
        }
      }

      return moment
    } catch (error) {
      console.error(`Error parsing moment file ${filename}:`, error)
      return null
    }
  }

  /**
   * Save moment to file system
   */
  async saveMoment(moment: PivotalMoment): Promise<boolean> {
    try {
      const filename = this.generateFilename(moment)
      const markdown = this.momentToMarkdown(moment)
      
      // Call API to save file
      const response = await fetch('/api/moments/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          filename,
          content: markdown,
          moment: moment
        }),
      })
      
      if (!response.ok) {
        console.error(`Failed to save moment ${moment.id}:`, response.statusText)
        return false
      }
      
      console.log(`Successfully saved moment: ${filename}`)
      return true
    } catch (error) {
      console.error(`Error saving moment ${moment.id}:`, error)
      return false
    }
  }

  /**
   * Save multiple moments as batch
   */
  async saveMoments(moments: PivotalMoment[]): Promise<{ saved: number; failed: number }> {
    let saved = 0
    let failed = 0

    // Process in batches to avoid overwhelming the server
    const batchSize = 5
    for (let i = 0; i < moments.length; i += batchSize) {
      const batch = moments.slice(i, i + batchSize)
      const promises = batch.map(moment => this.saveMoment(moment))
      const results = await Promise.all(promises)
      
      saved += results.filter(r => r).length
      failed += results.filter(r => !r).length
    }

    return { saved, failed }
  }

  /**
   * Load moments from file system
   */
  async loadMoments(): Promise<PivotalMoment[]> {
    try {
      const response = await fetch('/api/moments/load', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      })
      
      if (!response.ok) {
        console.error('Failed to load moments from files:', response.statusText)
        return []
      }
      
      const data = await response.json()
      const moments: PivotalMoment[] = []
      
      for (const file of data.files) {
        const moment = this.markdownToMoment(file.content, file.filename)
        if (moment) {
          moments.push(moment)
        }
      }
      
      console.log(`Loaded ${moments.length} moments from files`)
      return moments
    } catch (error) {
      console.error('Error loading moments from files:', error)
      return []
    }
  }

  /**
   * Delete moment file
   */
  async deleteMoment(momentId: string): Promise<boolean> {
    try {
      const response = await fetch('/api/moments/delete', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ momentId }),
      })
      
      return response.ok
    } catch (error) {
      console.error(`Error deleting moment ${momentId}:`, error)
      return false
    }
  }

  /**
   * Check if moments folder exists and is writable
   */
  async checkMomentsFolder(): Promise<{ exists: boolean; writable: boolean; count: number }> {
    try {
      const response = await fetch('/api/moments/status', {
        method: 'GET',
      })
      
      if (!response.ok) {
        return { exists: false, writable: false, count: 0 }
      }
      
      return await response.json()
    } catch (error) {
      console.error('Error checking moments folder:', error)
      return { exists: false, writable: false, count: 0 }
    }
  }
}

// Export singleton instance
export const momentFileProcessor = MomentFileProcessor.getInstance()